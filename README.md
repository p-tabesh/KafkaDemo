# KafkaDemo



کافکا ابزاری برای استریم و ارسال دیتاس حالا ایونت باشه یا مسیجینگ باشه
خصوصیتش اینه پرفورمنس خوبی داره و scalabel هست
و میلیونی پیام رو رد و بدل میکنه در زمان کم





کافکا چند تا مفهوم کلیدی داره

Broker
Producer
Consumer
Consumer Group
Topic 
Partition
Offset

Topic: هر جریان یا استریمی از دیتا رو میگیم تاپیک
فرض کنیم کافکا یه دیتابیسه، جدول هارو بهش میگیم تاپیک که هر نوع دیتا رو توش نگه میداره
هر تاپیک توی کافکا یسری پارتیشن قرار داره که برای مقیاس پذیری و پایداری هست که تو کافکا نیاز داریم
درواقع مسیج ها توی پارتیشن ها میشینن که توی تاپیک هستن و به تنهایی تاپیک تو خودش مسیج نگه نمیداره
کافکا تضمین میکنه که پیام ها توی یک پارتیشن به ترتیپ ورودشون به پارتیشن به استفاده کننده داده بشن
تو البته میگی به تاپیک بفرست ولی اون داستان پارتیشن پشت قضیس
توی کافکا اگر کلید نداشته باشه پیامی که پرودیوسر میفرسته، با الگوریتم راند رابین ارسال میکنه یعنی مثلا اگر 3 تا پارتیشن داره به 1 بعد 2 بعد 3 میفرسته، ولی اگر کلید داشته باشه، حتما همه پیام ها با اون کلید رو به یک پارتیشن خاص میفرسته و به پارتیشن دیگه ای نمیفرسته بخاطر hashing strategy هست.
حالا این مورد ترتیب برداشتنه مهمه چون توی برنامه ما ایونت های کسب و کاری ارسال میکنیم، مهمه که ترتیب ایونت های اتفاق افتاده چجوری بودن.
معمولا کلید ایونت هارو اسم روت اگریگیت ها میزارن که مشخص تر باشه.

وقتی یه ایونت میاد توی یه پارتیشن بشینه یه عدد بهش داده میشه که جایگاهش تو پارتیشن رو مشخص میکنه که بهش میگن Offset که به ازای هر پارتیشن وجود داره
این یه مزیت داره که کسی که ایونت رو برمیداره میدونه تا کجا برداشته
این داده ها Immuteble هستن
کلا ایونت ها درمورد یه اتفاق در گذشته هستن که immuteble اند که این تعریف با این ویژگی کافکا میخونه
کافکا روی دیسک نوشته میشه و تنظیم میشه کرد تا کی دیتا رو نگه داشت
پیشفرضش 1 هفتس

ما وقتی با دیتابیس داریم کار میکنیم، مستقیم وصل نمیشیم به دیتابیس درواقع، با استفاده از درایور ها وصل میشیم و مثلا کوئری میزنیم و اون دیتارو با اون زبان میاره
حالا کافکا یچیزی "شبیه" به این درایور داره، که بهش میگن Producer و Consumer
درواقع توی کدمون این Producer ها و Consumer هارو میسازیم و با اینها با کافکا صحبت میکنیم.
پس ما Producer رو برای ارسال دیتا و Consumer برای برداشتن دیتا ایجاد و استفاده میکنیم
کافکا خودش یچیزی به اسم پراکسی هم داره که REST Api هم میده
پرودیوسر ها تصمیم میگیرن تو کدوم پارتیشن بنویسن و هش رو حساب میکنن و اینکه تاپیک میبینن چند تا پارتیشن داره و با توجه به کلید میندازه توی یه پارتیشن

ساختار مسیج:
![[Pasted image 20250501185913.png]]


مورد دیگه اینکه چیزی جز بایت نمیفهمه، یعنی کارای سریالایز و دیسریالایز رو خود کانسیومر و پرودیوسر باید انجام بدن
اینکه فقط با بایت کار کنه باعث میشه CPU خیلی کمی بگیره

یه پروتوکل avro هست که با کافکا راحت تره استفاده ازین. که به همراه اسکیما رجیستری میشه استفاده کرد.

مکانیزم کانسیومر کافکا به صورت پولینگ هست که هی چک میکنه ببینه دیتا وجود داره یا نه
بعد دیتارو از تاپیک برمیداره و دیسریالایز میکنه و برمیگردونه برای استفاده

ما توی کافکا به تنهایی نمیگیم بروکر، میگیم کلاستر، چون درمورد چند تا بروکر صحبت میکنیم و میتونم چند تا سرور و بروکر داشته باشیم، که به یکیش وصل شیم به ادرس و پورتش، به کل کلاستر وصل شدیم.
![[Pasted image 20250501190842.png]]

بعد یه یچیزی داره به اسم رپلیکا و اینکه دیتا بین پارتیشن ها پخش میشه
مورد دیگه اینکه یه سرور بیاد پایین سرور دیگه ای هست که اون پارتیشنو داشته باشه و کارو راه بندازه.

کافکا به هر کانسیومر توی یک کانسیومر گروپ یک پارتیشن رو اختصاص میده
بعد حالا مثلا پارتیشنا بیشتر از کانسیومرا باشه
اون پارتیشن اضافرو میده به یکی ازون کانسیومر های موجود
ولی دو تا کانسیومر از یک پارتیشن توی یک کانسیومر گروپ نمیتونه استفاده کنه
اگر کانسیومر اضافی هم وجود داشته باشه در حالت idle میمونه و بهتره اضافی نداشته باشیم که اضافی منابع مصرف نکنه
بعد مهمه که ما کانسیومر گروپ داشته باشه که اضافه پردازش نکنه پیامو و اینکه داپلیکیت نشه.

برای خود کافکا یه پکیج zookeeper میخواد که یجورایی لیدر کلاستره البته که ورژن 4 به بعد نیاز نداره
کافکا رو لینوکس هم بهتر کار میکنه

پیشنهاد میشه برای هر میکرو سرویس یه تاپیک ایجاد شه
مگر یه اگریگیتی خیلی ایونت داشته باشه

خود کافکا نه بلکه کانسیومر باید نگه داره که تا کجا استفاده کرده و اینا. درواقع کافکا ولی نگه میداره که میگه فلان کانسیومر روی فلان پارتیشن به من گفت تا این افست خوندم
یه تنظیمات دیگه که کانسیومر میتونه داشته باشه اینه که بهش بگیم وقتی میاد بالا از کی شروع کنه خوندن

یه پترن Envelop وجود داره که پیشنهاد میشه برای ارسال ایونت از این حالت استفاده شه که جلوتر راجبش صحبت میکنیم.

![[Pasted image 20250502125655.png]]

خوبی این کار ساده تر و تمیز تر شدن ایونت
فضای ایونت هارو بهتره که تفکیک بکنیم
مثلا یه پکیج ایونت بسازیم، یا مثلا اسمبلی جدا نگه داریم. چون جزوی از پابلیک کانترکت ما با بیرون هست.
نکته دیگه اینکه پیشنهاد میشه اسم اون کانسیومر گروپ رو از فول نیم اسمبلی بگیره.
بعد اینکه اینطوری استفاده نمیکنیم که مثلا توی لایه اپلیکیشن بیایم پرودیوسر بسازیم و بعد که یه عملیات بیزنسی انجام شد برداره اونجا پیام رو پرودیوس کنه، ما نیاز به اوت باکس داریم.
پترن outbox هم جلوتر صبحت میکنیم.
حالا ما کنار دیتامون توی دیتابیس ایجاد میکنیم اونجایی که فکر میکنم دیتا توی اوتباکس نگه میدار
یه راه داره اینکه یه ابزاری خود کافکا داره به اسم کانکتور که خودش وصل میشه به دیتابیس
و دیتارو بکشن بیرون و بفرستن تو این حالت پرودیوسر نمینویسیم و این ابزار کارشو میکنه
کافکا کانکتور و دبزیوم داره
حالت دیگه اینکه یه Pooler بنویسیم که هر چند ثانیه یبار چک کنه ببینه تا کجا فرستاده

یه اشتباهی وجود داره که ممکنه فکر کنیم کافکا در پایان تصمیم میگیره به کدوم پارتیشن بفرسته پیام رو ولی در واقع پرودیوسر از قبل میدونه قراره تو کدوم پارتیشن پیام گذاشته بشه.

اگر یکی از بروکر های کافکا خراب شه پرودیوسر ها به طور اتوماتیک ریکاور میکنن پیام هارو.
